(* This contract implements a fungible token interface a la ERC20.*)
(* This contract does not fire events *)


(***************************************************)
(*               Associated library                *)
(***************************************************)
library FungibleToken

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let no_msg = Nil {Message}

let make_transfer_success_event =
    fun (withdrawnFrom: ByStr20) =>
    fun (depositedTo: ByStr20) =>
    fun (numTokens : Uint128) =>
        {_eventname: "Transfer Successful"; 
        from: withdrawnFrom; 
        to: depositedTo;
        num: numTokens}

let make_approve_success_event =
    fun (by: ByStr20) =>
    fun (to: ByStr20) =>
    fun (num : Uint128) =>
        {_eventname: "Approved";
        from: by;
        approved_user: to;
        numTokens: num}

let make_error_event =
    fun (calledFrom : String) =>
    fun (err : String) =>
        {_eventname: "Error";
        raised_at: calledFrom;
        error: err
        }


let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end
    

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract FungibleToken
(owner : ByStr20,
 total_tokens : Uint128)

(* Initial balance is not stated explicitly: it's initialized when creating the contract. *)

field balances : Map ByStr20 Uint128 =
  let m = Emp ByStr20 Uint128 in
    builtin put m owner total_tokens

(* Stores a mapping of tokenOwner to approved addresses along with the number of tokens approved *)
field allowed : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

transition BalanceOf (tokenOwner : ByStr20)
  bl <- balances;
  val = builtin get bl tokenOwner;
  match val with
  | Some v =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : v };
    msgs = one_msg msg;
    send msgs
  | None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; bal : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end

transition TotalSupply ()
  msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; total_tokens : total_tokens};
  msgs = one_msg msg;
  send msgs
end

transition Transfer (to : ByStr20, tokens : Uint128)
  bal <- balances[_sender];
  match bal with
  | Some b =>
    can_do = le_int tokens b;
    match can_do with
    | True =>
      (* subtract tokens from _sender and add it to to *)
      new_sender_bal = builtin sub b tokens;
      balances[_sender] := new_sender_bal;
      to_bal <- balances[to];
      match to_bal with
      | Some x =>
        new_to_bal = builtin add x tokens;
        balances[to] := new_to_bal
      | None =>
        balances[to] := tokens
      end;

      e = make_transfer_success_event _sender to tokens;
      event e
    | False =>
      (* balance not sufficient. *)
      e = let error_msg = "Insufficient Balance" in let current_location = "Transfer" in
            make_error_event current_location error_msg;
      event e
    end
  | None =>
    (* no balance record, can't transfer *)

      e = let error_msg = "Insufficient Balance" in let current_location = "Transfer" in
            make_error_event current_location error_msg;
      event e
  end
end

transition TransferFrom (from : ByStr20, to : ByStr20, tokens : Uint128)
  m_disallowed = "Transfer not allowed";
  getBalanceFrom <- balances[from];
  match getBalanceFrom with
  | Some balanceAvailable =>
      (* Check if _sender has been authorized by "from" *)
      numTokensTransferable <- allowed[from][_sender];
      
      match numTokensTransferable with
      | Some numTokens =>
        (* We can only transfer the minimum of available or authorized tokens *)
        tokensToBeTransferred = let val = min_int balanceAvailable numTokens in 
                                min_int val tokens;
        not_allowed = builtin lt tokensToBeTransferred tokens;
        match not_allowed with
        | True =>
            (* Operation not allowed *)
            e = let error_msg = "Not allowed" in let current_location = "TransferFrom" in 
                make_error_event current_location error_msg;
            event e
        | False =>
            (* Operation allowed *)
            newBalanceFrom = builtin sub balanceAvailable tokensToBeTransferred;
            balances[from] := newBalanceFrom;

            (* Calculate recepient's new balance *)
            getRecipientBal <- balances[to];
            match getRecipientBal with
            | Some bal =>
                newRecipientBalance = builtin add bal tokensToBeTransferred;
                balances[to] := newRecipientBalance
            | None =>
                balances[to] := tokensToBeTransferred
            end;
            (* reduce "allowed" by "tokens" *)
            new_allowed = builtin sub numTokens tokensToBeTransferred;
            allowed[from][_sender] := new_allowed;

            (* Emit event to indicate that transfer is successful *)
            e = make_transfer_success_event from to tokensToBeTransferred;
            event e
        end
        
      | None =>
          e = let error_msg = "Not allowed" in let current_location = "TransferFrom" in 
                make_error_event current_location error_msg;
          event e
      end

  | None =>
  
      e = let error_msg = "Not allowed" in let current_location = "TransferFrom" in 
                make_error_event current_location error_msg;
      event e
  end

end

transition Approve (spender : ByStr20, tokens : Uint128)
  allowed[_sender][spender] := tokens;
  e = make_approve_success_event _sender spender tokens;
  event e
end

transition Allowance (tokenOwner : ByStr20, spender : ByStr20)
  al <- allowed;
  towner_map = builtin get al tokenOwner;
  match towner_map with
  | Some m =>
    spender_allowance = builtin get m spender;
    match spender_allowance with
    | Some n =>
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; allowed : n };
      msgs = one_msg msg;
      send msgs
    | None =>
      msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; allowed : Uint128 0 };
      msgs = one_msg msg;
      send msgs
    end
  | None =>
    msg = { _tag : "Main"; _recipient : _sender; _amount : Uint128 0; allowed : Uint128 0 };
    msgs = one_msg msg;
    send msgs
  end
end
